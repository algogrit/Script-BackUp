#!/usr/bin/env bash
# rename-enmasse.sh
# Bulk renaming utility: renames files matching a pattern with numbered sequence.
# Supports:
#   - Dry run (-n)
#   - Optional step size
#   - Optional zero-padding width (-p N)

set -euo pipefail

dry_run=false
pad_width=0

# --- Parse options ---
while getopts ":np:" opt; do
  case $opt in
    n) dry_run=true ;;
    p) pad_width="$OPTARG" ;;
    *) echo "Usage: $0 [-n] [-p width] <pattern> <new_name_prefix> <start_number> [step]"
       echo "Example: $0 -n -p 4 '*.jpg' photo_ 100 5"
       exit 1 ;;
  esac
done
shift $((OPTIND - 1))

# --- Validate arguments ---
if [[ $# -lt 3 ]]; then
  echo "Usage: $0 [-n] [-p width] <pattern> <new_name_prefix> <start_number> [step]"
  echo "Example: $0 -n -p 4 '*.jpg' photo_ 100 5"
  exit 1
fi

pattern="$1"
prefix="$2"
start="$3"
step="${4:-1}"

counter="$start"

shopt -s nullglob
files=($pattern)
if [[ ${#files[@]} -eq 0 ]]; then
  echo "No files found for pattern: $pattern"
  exit 1
fi

# --- Calculate padding width (auto if not specified) ---
if [[ "$pad_width" -le 0 ]]; then
  max_number=$((start + (${#files[@]} - 1) * step))
  pad_width=${#max_number}
fi

echo "Found ${#files[@]} files."
$dry_run && echo "Dry run mode: no files will be renamed."
echo "Padding width: $pad_width"
echo

# --- Sort files naturally ---
IFS=$'\n' files=($(printf "%s\n" "${files[@]}" | sort -V))

for f in "${files[@]}"; do
  ext="${f##*.}"
  newname="${prefix}$(printf "%0${pad_width}d" "$counter").${ext}"
  echo "$f  →  $newname"
  if ! $dry_run; then
    mv -i -- "$f" "$newname"
  fi
  counter=$((counter + step))
done

echo
if $dry_run; then
  echo "✅ Dry run complete — no files renamed."
else
  echo "✅ Renamed ${#files[@]} files starting from $start (step $step)."
fi
